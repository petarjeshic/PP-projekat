
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.util.MyTab;
import rs.ac.bg.etf.pp1.util.MyStruct;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.structure.SymbolDataStructure;
import java.util.Stack;
import java.util.Collection;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
import rs.etf.pp1.mj.runtime.Code;
parser code {:
	
	boolean errorDetected=false;
	Logger log=Logger.getLogger(getClass());
	public void report_fatal_error(String message,Object info)throws java.lang.Exception{
		done_parsing();
		report_error(message,info);
	}
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska",cur_token);
	}
	public void unrecovered_syntax_error(Symbol cur_token)throws java.lang.Exception{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti",cur_token);
	}
	public void report_error(String message,Object info){
		errorDetected=true;
		StringBuilder msg=new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
	public void report_info(String message,Object info){
		StringBuilder msg=new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.info(msg.toString());
	}
:}

action code {:
	Obj currentMethod = null;
	Obj _this;
	Obj currentClass;
	
	Struct currentType, currentMethType;
	Struct varType = null;
	Struct newClass=null;
	
	boolean main=false;
	boolean returnFound=false;
	boolean in_class = false; 
	boolean in_method = false;
	boolean in_for=false;
	boolean ok=true;
	
	int printCallCount;
	int array_count = 0;	
	int var_count = 0;
	int con_count = 0;
	int const_value=0;
	int mainDeclarations = 0;
	int formParsNum=0;

	boolean vtSet = false;
	Map<String, Obj> redefiningMap = new HashMap<String, Obj>(); 
	SymbolDataStructure extendsSymbols = null;
	
	Scope globalScope = null;
	Scope functionScope=null;
	Scope classScope=null;
	//counter-i
	int global_scope=0;
	
	Stack<Obj> callingStack = new Stack<Obj>();
	Stack<Integer> actParsStack = new Stack<Integer>();
			
:}

init with {:
	MyTab.init(); //Universe obseg
:}


scan with{:
	Symbol s=this.getScanner().next_token();
	if(s!=null && s.value!=null)
		log.info(s.toString()+" "+s.value.toString());
	return s;
:}




terminal PROG,VOID,LBRACE,RBRACE,SEMI, LPAREN, RPAREN, COMMA,PRINT,RETURN,PLUS,EQUAL, LMEDBRACE,RMEDBRACE,DOT;
terminal GREATER,LOWER,BREAK,CLASS,ELSE,CONST,IF,NEW,READ,FOR,EXTENDS,CONTINUE,STATIC;
terminal MINUS,MULI,DIVI,MODI,EQEQ,NOTEQ,GREATEQ,LOWEQ,AND,OR,PLUSEQ,MINUSEQ,MULEQ,DIVEQ,MODEQ,PLUSPLUS,MINUSMINUS;

terminal String STRING;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;

non terminal Program,MethodDecl,VarDeclList,MethodDeclList,VarDecl,StatementList, FormParamList ;
non terminal Statement,ActPars,ActualPars,ClassName,Extends,OptionalMethods;
non terminal ConstDecl,Const,IdentList,Var,VarList;
non terminal ClassDecl,DesignatorStatement,Condition,DesignatorStatementList;
non terminal ConditionList,NumConstList,CondTermList,ClassVarDeclList;
non terminal CondFact,If,ClassVarDecl;
non terminal Assignop,AddopLeft,AddopRight,MulopRight,MulopLeft,CondTerm;
non terminal CondFactList,Matched,Unmatched,SomeDeclList,VarArgs;

non terminal Obj ProgName,Designator,FieldDeclList,Field;
non terminal Struct Type,Term,Expr,Factor;
non terminal Integer Relop,Addop,Mulop,FormPars;

Program ::= PROG ProgName:p 
			{:
				MyTab.openScope();
				
			:} 
			SomeDeclList LBRACE MethodDeclList RBRACE
			{:
				Code.dataSize=MyTab.currentScope().getnVars();	
				MyTab.chainLocalSymbols(p);
				MyTab.closeScope();
				
				for(Obj s : p.getLocalSymbols())
					if(s.getKind() == Obj.Var)
						if(s.getType().getKind() == Struct.Array)
							array_count++;
						else
							var_count++;
					else if(s.getKind() == Obj.Con)
						con_count++;
				
				parser.report_info("Broj globalnih prostih promenjivih:" +var_count,null);
				parser.report_info("Broj globalnih nizova:" + array_count,null);
				parser.report_info("Broj globalnih konstanti:" + con_count,null);
				parser.report_info("Broj deklaracija promenljivih u main-u:" + mainDeclarations,null);	
			:}
			;
ProgName ::= IDENT:pName
			{:
			
			globalScope=MyTab.currentScope();
			
			Obj len = MyTab.find("len");
			len.setAdr(Code.pc);
			Code.put(Code.enter);
			Code.put(1);
			Code.put(1);
			Code.put(Code.load);
			Code.put(0);
			Code.put(Code.arraylength);
			Code.put(Code.exit);
			Code.put(Code.return_);
			 
			Obj chr = MyTab.find("chr");
			chr.setAdr(Code.pc);
			Code.put(Code.enter);
			Code.put(1);
			Code.put(1);
			Code.put(Code.load);
			Code.put(0);
			Code.put(Code.exit);
			Code.put(Code.return_);
			  
			Obj ord = MyTab.find("ord");
			ord.setAdr(Code.pc);
			Code.put(Code.enter);
			Code.put(1);
			Code.put(1);
			Code.put(Code.load);
			Code.put(0);
			Code.put(Code.exit);
			Code.put(Code.return_);
			RESULT= MyTab.insert(Obj.Prog,pName,MyTab.noType);
			 :};
   
SomeDeclList ::= SomeDeclList ConstDecl
				|
				SomeDeclList VarDecl
				|
				SomeDeclList ClassDecl
				|
				/*epsilon*/
				;
ConstDecl ::= CONST Type IDENT:name EQUAL IdentList:o SEMI
			 {:
				  	if(MyTab.currentScope.findSymbol(name) != null)
				  		parser.report_error("Greska na liniji: "+nameleft+". Vec postoji identifikator sa imenom: " + name,null);
				  	else {
				  		Obj temp = MyTab.insert(Obj.Con, name, currentType);
				  		temp.setAdr(const_value);
				  		if(!o.equals(currentType))
				  			parser.report_error("Greska na liniji: " + nameleft+" . Tip koji se dodeljuje ne odgovara tipu kome se dodeljuje. ",null);
				  		parser.report_info("Deklarisana globalna konstanta " + name + " na liniji " + nameleft, null);
				  	}
				  	if(global_scope==0)
					con_count++;
			  :}
			  |
			  CONST error SEMI:s 
			  {: 
			  	parser.report_info("Uspesan oporavak od greske na liniji " + sleft + " pri definisanju konstante.",null); 
		  	  :};
IdentList ::=IdentList COMMA IDENT:name EQUAL Const:o 
			{:
				if(MyTab.currentScope.findSymbol(name) != null)
				  		parser.report_error("Greska na liniji: "+nameleft+". Vec postoji identifikator sa imenom: " + name,null);
				  	else {
				  		Obj temp = MyTab.insert(Obj.Con, name, currentType);
				  		temp.setAdr(const_value);
				  		if(!o.equals(currentType))
				  			parser.report_error("Greska na liniji: " + nameleft+" . Tip koji se dodeljuje ne odgovara tipu kome se dodeljuje. ",null);
				  		parser.report_info("Deklarisana globalna konstanta " +name + " na liniji " + nameleft, null);
				  	}
				  if(global_scope==0)
				  con_count++;
				  RESULT=o;
			:}
			|
			Const:o
			{:
				RESULT=o;
			:}
			;
Const ::= NUMBER:num
			{:
				const_value=num;
				RESULT = MyTab.intType;  
				
			:}
			|CHAR:chr
			{:
				const_value=(int)chr;
				RESULT = MyTab.charType; 
			:}
			|BOOL:bool
			{:
				if(bool.equals("true"))
				const_value = 1;
				else 
				const_value = 0;
				RESULT = MyTab.boolType; 
			:}
			;
VarDecl ::= Type VarList SEMI
			{:
				currentType=null;
			:}
				|
		    Type error SEMI:s 
		   	{: 
		   		currentType=null;
		  		parser.report_info("Uspesan oporavak od greske pri definisanju globalne promenljive na liniji " + sleft,null); 
	  	   	:};
VarList ::= Var COMMA VarList
			{:
			if(main)
			mainDeclarations++;
			:}
			| 
			Var
			{:
			if(main)
			mainDeclarations++;
			:}
			| 
			error COMMA:c VarList
			{:
			parser.report_info("Uspesan oporavak od greske pri definisanju globalne promenljive na liniji " + cleft,null); 
			:}
			;
Var ::= IDENT:name
		{:	
			Obj var = MyTab.find(name);
			if(var != MyTab.noObj) {
				parser.report_error("Semanticka greska na liniji " + nameleft + " : Ime promenljive vec postoji!", null);
			}
			else if(currentType != null) {
				MyTab.insert(Obj.Var, name, currentType);
				parser.report_info("Deklarisana promenljiva " + name + " na liniji " + nameleft, null);
			}
			if(global_scope==0)
			var_count++;
		:}
 			|
 		IDENT:name LMEDBRACE RMEDBRACE
 		{: 
			Obj var = MyTab.find(name);
			if(var != MyTab.noObj) {
				parser.report_error("Semanticka greska na liniji " + nameleft + " : Ime promenljive vec postoji!", null);
			}
			else if(currentType != null) {
				Struct arrayType = new Struct(Struct.Array);
				arrayType.setElementType(currentType);
				MyTab.insert(Obj.Var, name, arrayType);
				parser.report_info("Deklarisan niz " + name + " na liniji " + nameleft, null);
			}
			if(global_scope==0)
			array_count++;
		:};
ClassDecl ::= CLASS ClassName:c Extends 	
			  {:
			  	//PRVO UBACUJEMO POLJA POTKLASE
			  	//DRUGO UBACUJEMO POLJA NATKLASE
			  	//TRECE UBACUJEMO METODE POTKLASE
			  	//CETVRTO UBACUJEMO METODE NATKLASE
			  				  	
			  	if(extendsSymbols!=null) {
				  	for(Obj s: extendsSymbols.symbols()) {
				  			if(s.getKind() == Obj.Fld) {	//POLJE
				  				if(MyTab.currentScope().findSymbol(s.getName()) == null) {
				  					Obj obj = MyTab.insert(s.getKind(), s.getName(), s.getType());
				  				}
				  			}
				  			else if(s.getKind() == Obj.Meth) {
				  				if(MyTab.currentScope().findSymbol(s.getName()) == null) {
				
									Obj currentMeth = MyTab.insert(s.getKind(), s.getName(), s.getType());
										
									currentMeth.setLevel(s.getLevel());
									currentMeth.setAdr(s.getAdr());
										
									MyTab.openScope();
									global_scope++;	
									Collection<Obj> locals = s.getLocalSymbols();
									Iterator it = locals.iterator();
										
									for(int i=0; i<s.getLevel(); i++) {
										if(it.hasNext()) {
											MyTab.currentScope().addToLocals((Obj)it.next());
										}
									}
									MyTab.chainLocalSymbols(currentMeth);
									global_scope--;
									MyTab.closeScope();
									
									//UBACIVANJE U VIRTUELNU TABELU
									String name = currentMeth.getName().toString();
									for(int i=0; i<name.length(); i++) {	
										Obj obj = new Obj(Obj.Var, "#" + globalScope.getnVars() + name.charAt(i), MyTab.charType);
										
										globalScope.addToLocals(obj);
										
										if(!vtSet) {
											Obj vtPtr = MyTab.currentScope().findSymbol("vtPtr");
											
											vtPtr.setFpPos(obj.getAdr());
										}
										obj.setLevel(0);
									}
									
									//DA SE ZNA DA JE KRAJ IMENA
									Obj obj = new Obj(Obj.Var, "#" + globalScope.getnVars() + "-1", MyTab.intType);
									globalScope.addToLocals(obj);
									obj.setLevel(0);
									obj = new Obj(Obj.Var, "#adr_" + name.toString() + globalScope.getnVars() + "-" + currentMeth.getAdr(), MyTab.intType);
									globalScope.addToLocals(obj);
									//OVDE MI TREBA OBJ.GETADR ZBOG REDEFFINISANJA
									redefiningMap.put(currentMeth.getName(), obj);
									obj.setLevel(0);
								}
				  			}
				  	}
					
					MyTab.chainLocalSymbols(newClass);
				}
				
			  :}
			  LBRACE ClassVarDeclList OptionalMethods RBRACE 
			  {: 
					
				MyTab.chainLocalSymbols(newClass);
				
			  	if(true) {		//if(ok)							  
			  		Obj obj = new Obj(Obj.Var, "#vt_finish" + globalScope.getnVars(), MyTab.intType);
			  		globalScope.addToLocals(obj);
			  		obj.setLevel(0);
			  		global_scope--;
			  		MyTab.closeScope();
			  		vtSet = false;
			  		parser.report_info("Definisana klasa " + c + " na liniji " + cleft, null);
			  	}
			  	
			  	classScope = null;
			  	newClass = null;
			  	extendsSymbols = null;
			  	
			  	redefiningMap.clear();
			  :} 
			  ;
OptionalMethods::=LBRACE MethodDeclList RBRACE
				|
				/*epsilon*/;			  
ClassName ::= IDENT:className 
			  {:
			  	Obj classNode = MyTab.find(className);
			  	if(classNode != MyTab.noObj) {
			  		parser.report_error("Semanticka greska na liniji " + classNameleft + " : Ime klase se vec koristi! ", null);
			  		RESULT = MyTab.noObj;
			  		ok = false;
			  	}
			  	else {				
			  		newClass = new Struct(Struct.Class);
				  	
				  	Obj obj = MyTab.insert(Obj.Type, className, newClass);				  	
				  	
				  	RESULT=className;
				  	MyTab.openScope();
				  	global_scope++;
				  	classScope = MyTab.currentScope();
				  	
				  	Obj vtPtr = MyTab.insert(Obj.Fld, "vtPtr", MyTab.intType);
				  					  	
				  	MyTab.chainLocalSymbols(newClass);
				  	
				  	parser.report_info("Obradjuje se klasa " + className + " na liniji " + classNameleft, null);
				  	ok = true;
					
				}
			  :};

Extends ::= EXTENDS Type:t 
			{:
				if(t.getKind() != Struct.Class) {
					parser.report_error("Semanticka greska na liniji " + tleft + ": Tip za extends mora biti klasa! ", null);
				}
				else {
					
					newClass.setElementType(t);	//POSTAVIMO KO MU JE NATKLASA!!!
					
					extendsSymbols = t.getMembersTable();
					
					
					MyTab.chainLocalSymbols(newClass);
					RESULT=t;
				}
			:}   
			| 
			error 
			|
			EXTENDS error
			| 
			/*epsilon*/;	/*mozda moze i EXTENDS error*/

ClassVarDeclList ::= ClassVarDeclList ClassVarDecl | /*epsilon*/;

ClassVarDecl ::= Type FieldDeclList SEMI
				 |
				 Type error:e SEMI
				 {: 
				 parser.report_error("Uspesan oporavak od greske na liniji: "+eleft+".",null); :} 
				 |
				 error
				 |
				 Type error
				 ;

FieldDeclList ::= FieldDeclList COMMA Field | Field ;

Field ::=IDENT:vName 
		  {: 

			Obj var = MyTab.currentScope().findSymbol(vName);
			
			if(var != null) {
			
				if(newClass.getElemType() !=null && newClass.getElemType().getMembersTable().searchKey(vName) == null)
					
					parser.report_error("Semanticka greska na liniji " + vNameleft + " : Ime promenljive vec postoji!", null);
				
				else {
					MyTab.currentScope().getLocals().deleteKey(vName);
					
					MyTab.insert(Obj.Fld, vName, currentType);
				
					MyTab.chainLocalSymbols(newClass);
					
					parser.report_info("Deklarisano polje " + vName + " tipa " + currentType + " na liniji " + vNameleft, null);
				}
			}
			else if(currentType != null) {
				MyTab.insert(Obj.Fld, vName, currentType);
				
				MyTab.chainLocalSymbols(newClass);
				
				parser.report_info("Deklarisano polje " + vName + " tipa " + currentType + " na liniji " + vNameleft, null);
			}
		  :}
		  |
		  IDENT:vName LMEDBRACE RMEDBRACE 
		  {: 
			//proveri da li ima kolizije
			Obj var = MyTab.currentScope().findSymbol(vName);
			if(var != null) {
				if(newClass.getElemType() !=null && newClass.getElemType().getMembersTable().searchKey(vName) == null)
					
					parser.report_error("Semanticka greska na liniji " + vNameleft + " : Ime promenljive vec postoji!", null);
				
				else {
					MyTab.currentScope().getLocals().deleteKey(vName);
					
					Struct arrayType = new Struct(Struct.Array);
					arrayType.setElementType(currentType);
					MyTab.insert(Obj.Fld, vName, arrayType);
					
					MyTab.chainLocalSymbols(newClass);
					
					parser.report_info("Deklarisan niz kao polje " + vName + " na liniji " + vNameleft, null);
				}
			}
			else if(currentType != null) {
				Struct arrayType = new Struct(Struct.Array);
				arrayType.setElementType(currentType);
				MyTab.insert(Obj.Fld, vName, arrayType);
				
				MyTab.chainLocalSymbols(newClass);
				
				parser.report_info("Deklarisan niz kao polje " + vName + " na liniji " + vNameleft, null);
			}
		  :}
		  ; 
MethodDeclList ::= MethodDeclList:m MethodDecl
				  {:
				   RESULT=m;
				  :}
				  |
				  /*epsilon*/
				  ;
MethodDecl ::=Type:retType IDENT:methName 
				{:
					Obj funkcija=MyTab.find(methName);
					if(funkcija==MyTab.noObj){
						parser.report_info("Obradjuje se metoda: "+methName+" na liniji "+methNameleft,null);
						currentMethod=MyTab.insert(Obj.Meth,methName,retType);
						if(methName.equalsIgnoreCase("main")){
							Code.mainPc=Code.pc;
							main=true;
							}
						currentMethType=currentType;
						MyTab.openScope();
						in_method=true;
						//currentMethod.setAdr(Code.pc);
						}
					else {
						parser.report_error("Semanticka greska na liniji " + methNameleft + " : Ime funkcije vec postoji!", null);
					}
					
				:}
				LPAREN FormPars  RPAREN VarDeclList LBRACE
				{:
				currentMethod.setLevel(formParsNum);
				functionScope=MyTab.currentScope();
				global_scope++;
				Code.put(Code.enter);
				Code.put(formParsNum);
				Code.put(functionScope.getnVars()); //broj promenljivih u trenutnom scope-u.
			:} 
			 StatementList RBRACE
			{: 
				if(in_class) 
					  		_this = MyTab.insert(Obj.Var, "this", MyTab.noType);
				if(!returnFound && retType != MyTab.noType)
					parser.report_error("Semanticka greska na liniji: "+methNameleft+". Funkcija: "+methName+" nema return iskaz.",null);
				MyTab.chainLocalSymbols(currentMethod);
				currentMethod.setLocals(MyTab.currentScope.getLocals());
				MyTab.closeScope();
				Code.put(Code.exit);
				Code.put(Code.return_);
				if(currentMethType!=MyTab.noType && returnFound==false){
					Code.put(Code.trap);
					Code.put(1);
				}
				global_scope--;
				functionScope=null;
				main=false;
				returnFound=false;
				in_method=false;
				currentMethType=null;
				formParsNum=0;
				currentMethod=null;	
			:}
			|
			STATIC Type:retType IDENT:methName LPAREN FormPars  RPAREN VarDeclList LBRACE
			{:  
				if(!in_class==true)
					parser.report_error("Greska na liniji: "+retTypeleft+". Staticka funkcija: "+methName+" mora biti unutar klase.",null);
				in_method=true;
				currentMethod=MyTab.insert(Obj.Meth,methName,currentType);
				currentMethType=retType;
				MyTab.openScope();
				functionScope=MyTab.currentScope();
				global_scope++;
				parser.report_info("Obradjuje se metoda: "+methName+" na liniji "+methNameleft,null);
			:} 
			 StatementList RBRACE
			{: 
				if(!returnFound && retType != MyTab.noType)
					parser.report_error("Semanticka greska na liniji: "+methNameleft+". Funkcija: "+methName+" nema return iskaz.",null);
				MyTab.chainLocalSymbols(currentMethod);
				returnFound=false;
				currentMethod=null;	
				currentMethType=null;
				global_scope--;
				MyTab.closeScope();
				functionScope=null;
				in_method=false;
			:}
			;
VarArgs ::=Type:typeName DOT DOT DOT IDENT
			|
			/*epsilon*/;				
			
VarDeclList ::= VarDeclList VarDecl
				|
				/*epsilon*/
				;
FormPars ::= Type:type IDENT:name LMEDBRACE RMEDBRACE FormParamList VarArgs
			{:
				parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
				if(MyTab.currentScope.findSymbol(name)!=null)
					{
						parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
					}
				else {
					Struct arrayType=new Struct(Struct.Array);
					arrayType.setElementType(currentType);
					Obj temp = MyTab.insert(Obj.Var, name, arrayType);
					formParsNum++;
					}
			
			:}
			|
			Type:type IDENT:name FormParamList VarArgs
			{:
				parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
				if(MyTab.currentScope.findSymbol(name)!=null)
					{
						parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
					}
				else {
					Obj temp = MyTab.insert(Obj.Var, name, currentType);
					formParsNum++;
					}
			
			:}
			| 
			VarArgs;
			
FormParamList ::= FormParamList:f COMMA Type:type IDENT:name LMEDBRACE RMEDBRACE
				  {:
					parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
				if(MyTab.currentScope.findSymbol(name)!=null)
					{
						parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
					}
				else {
					Struct arrayType=new Struct(Struct.Array);
					arrayType.setElementType(currentType);
					Obj temp = MyTab.insert(Obj.Var, name, arrayType);
					formParsNum++;
					}
			
				  :}
				  |
				  FormParamList:f COMMA Type:type IDENT:name
				  {:
					parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
					if(MyTab.currentScope.findSymbol(name)!=null)
						{
							parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
						}
					else {
						Obj temp = MyTab.insert(Obj.Var, name, currentType);
						formParsNum++;
						RESULT=f;
						}
			
				  :}
				  |
				  /*epsilon*/
				  ;
Type ::= VOID
		{:
			RESULT=MyTab.noType;
		:}
		|
		IDENT:vType
		{:
			Obj typeNode = MyTab.find(vType);
			if(typeNode != MyTab.noObj) {
				if(typeNode.getKind() == Obj.Type) {
					currentType = typeNode.getType();
					
					//OVDE PROVERI DA LI JE U PITANJU KLASA DA BI PRIKAZALA KORISCENJE
					if(currentType.getKind() == Struct.Class)
						parser.report_info("Koriscenje klase " + vType + " kao tipa na liniji " + vTypeleft, null);
					
					RESULT = currentType;
				}
				else {
					parser.report_error("Ime " + vType + " nije tip!" , null);
					RESULT = MyTab.noType;
				}
			}
			else {
				parser.report_error("Semanticka greska na liniji " + vTypeleft + ":" + " Nije pronadjen tip " + vType + "!" , null);
				RESULT = MyTab.noType;
			}
		:}
		;
		
Statement ::= Matched | Unmatched;
If::=IF LPAREN Condition:cond
			{:
				if(cond.equals(Struct.Bool)){
					parser.report_error("Greska na liniji: "+condleft+". Uslov mora biti boolean tipa.",null);
				}
			:} 
			RPAREN;
Unmatched ::= If Statement
			| 
			If Matched ELSE Unmatched;
Matched ::= DesignatorStatement SEMI
			|
			Designator:func
			{:
				callingStack.push(func); 
				actParsStack.push(0);
			:}
			 LPAREN ActualPars RPAREN SEMI
			{:
			
			if(Obj.Meth == func.getKind()){
				parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji: "+funcleft,null);
				int formalPars = func.getLevel();
				if(formalPars > actParsStack.peek()) {	//U ActParsList smo obradili <
					parser.report_error("Semanticka greska na liniji " + funcleft + ": broj stvarnih i formalnih parametara mora biti isti!", null);
				}
				else {	//AKO JE SVE ISPRAVNO SEMANTICKI
				
							int destAdr = func.getAdr() - Code.pc;	//func.getAdr() DAJE ADRESU PRVE INSTRUKCIJE U FJI
							Code.put(Code.call);
							Code.put2(destAdr);	//put2 STAVLJA RELATIVAN SKOK
							if(!func.getType().equals(MyTab.noType)) {
								Code.put(Code.pop);
							}
							
				}
				}
			else {
				parser.report_error("Greska na liniji: "+funcleft+" ime: "+func.getName()+" nije funkcija.",null);
				RESULT=MyTab.noType;
				}
			callingStack.pop();
			actParsStack.pop();
			:}
			|
			If Matched ELSE Matched
			|
			FOR LPAREN DesignatorStatementList SEMI ConditionList SEMI DesignatorStatementList RPAREN
			{:
				in_for=true;
			:}
			Matched
			{:
				in_for=false;
			:}
			|
			BREAK:b SEMI
			{:
				if(in_for==false)
					parser.report_error("Greska na liniji: "+bleft+". Break mora biti unutar for petlje.",null);
			:}
			|
			CONTINUE:c SEMI
			{:
				if(in_for==false)
					parser.report_error("Greska na liniji: "+cleft+". Continue mora biti unutar for petlje.",null);
			:}
			|
			RETURN Expr:t
			{:	
				returnFound=true;
				if(in_method=false){
					parser.report_error("Greska na liniji: "+tleft+". Iskaz RETURN se moze koristiti samo unutar metoda i funkcija.",null);
				}
				if(currentMethType==MyTab.noType){
					parser.report_error("Greska na liniji: "+tleft+". Povratni tip funkcije je VOID i ne moze imati vrednost u return iskazu.",null);
				}
				if(currentMethType.getKind()!=t.getKind()){
					parser.report_error("Greska na liniji: "+tleft+". Tip izraza u return naredbi se ne slaze sa tipom povratne vrednosti funkcije.",null);
				
				}
				Code.put(Code.exit);
				Code.put(Code.return_);
			:} 
			SEMI
			|
			RETURN:linija SEMI
			{:
				if (currentMethType != MyTab.noType)
					parser.report_error("Greska na liniji "+ linijaleft + ":metod ne sme imati return bez izraza jer nije void!",null);
			:}
			|
			READ LPAREN Designator:des RPAREN SEMI
			{:
				if (des.getKind()!=Struct.Int&&des.getKind()!=Struct.Char&&des.getKind()!=Struct.Bool)
					parser.report_error("Greska na liniji "+ desleft + ". Izraz mora biti integer, boolean ili char.",null);
				else{	
					if(des.getKind() == Struct.Int) {
								Code.put(Code.read);	//ZA READ NEMA NIKAKVIH ARGUMENATA, ZATO NE STAVLJAM NISTA NA STEK
								Code.store(des); 			
					}
					else if(des.getKind() == Struct.Char) {
								Code.put(Code.bread);
								Code.store(des);
					}
					else if(des.getKind() == Struct.Bool) {
								Code.put(Code.read);
								Code.store(des);
					}
				}
			:}
			|
			PRINT LPAREN Expr:e NumConstList:numC RPAREN SEMI
			{:
				if (e.getKind()!=MyStruct.Int&&e.getKind()!=MyStruct.Char&&e.getKind()!=MyStruct.Bool)
					parser.report_error("Greska na liniji "+ eleft + ". Izraz mora biti integer, boolean ili char.",null);
				if(e.getKind()==MyStruct.Int){
					Code.loadConst((int)numC);
					Code.put(Code.print);
				}
				if(e.getKind()==MyStruct.Char){
					Code.loadConst((int)numC);
					Code.put(Code.bprint);
				}
				if(e.getKind()==MyStruct.Bool){
					
				}
			:}
			|
			LBRACE StatementList RBRACE
			 ;
StatementList ::= StatementList Statement
			     |
			     /*epsilon*/
			     ;
ConditionList ::=Condition| /*epsilon*/;
NumConstList ::= COMMA NUMBER:n {:RESULT=n;:}|/*epsilon*/{:RESULT=1;:};
DesignatorStatementList ::=DesignatorStatement
							|
							/*epsilon*/
							;
DesignatorStatement ::= Designator:dest Assignop:op Expr:e
						{:
							Obj ex=MyTab.find(e.toString());
							if(dest.getType().getKind()!=Struct.Array&&dest.getType().getKind()!=Struct.Int&&dest.getType().getKind()!=Struct.Char&&dest.getType().getKind()!=Struct.Bool&&dest.getType().getKind()!=Struct.Class){
								parser.report_error( "Tip kome se dodeljuje mora biti promenljiva, element niza ili polje unutar objekta. Greska na liniji " + destleft,null);
		 						RESULT=MyTab.noType;
							}
							else
							if (e.getKind()!=dest.getType().getKind()) {
		 						parser.report_error( "Ovaj tip se ne moze dodeliti promenjivoj tipa: " + dest.getType().getKind() + " - Greska na liniji " + destleft,null);
		 						RESULT=MyTab.noType;
		 						}
		 					if((Integer)op!=Code.eq){
		 					Code.load(dest);
		 					Code.put((int)op);
		 					}
		 					Code.store(dest);
							RESULT=dest;
						:}
						|
						Designator:dest PLUSPLUS:op
						{:
							if(dest.getType().getKind()!=Struct.Array&&dest.getType().getKind()!=Struct.Int&&dest.getType().getKind()!=Struct.Char&&dest.getType().getKind()!=Struct.Bool&&dest.getType().getKind()!=Struct.Class){
								parser.report_error( "Tip kome se dodeljuje mora biti promenljiva, element niza ili polje unutar objekta. Greska na liniji " + destleft,null);
		 						RESULT=MyTab.noType;
							}
							if(dest!=null) {
							if(dest.getKind()!=Struct.Int) 
		 						parser.report_error("Promenljiva: "+dest+" mora biti tipa int. - Greska na liniji " + destleft,null);
							}
							else {
								if(dest.getKind() == Obj.Elem) {
								Code.put(Code.dup2);
							}
							
							Code.load(dest);
							Code.loadConst(1);
							Code.put((int)Code.add); 
							Code.store(dest);
							}
							RESULT=dest;
						:}
						|
						Designator:dest MINUSMINUS:op
						{:
							if(dest!=null) {
							if(dest.getKind()!=Struct.Int) 
		 						parser.report_error("Promenljiva: "+dest+" mora biti tipa int. - Greska na liniji " + destleft,null);
							}
							else {
								if(dest.getKind() == Obj.Elem) {
								Code.put(Code.dup2);
							}
							
							Code.load(dest);
							
							Code.loadConst(1);
							Code.put(Code.sub); 
							Code.store(dest);
							}
							RESULT=dest;
						:}
						;
Condition ::= CondTerm:cond CondTermList
			 {:
			 	RESULT=0;
			 :}
			 ;
CondTermList ::= CondTermList:c OR CondTerm
				{:
					RESULT=c;
				:}
				|
				/*epsilon*/
				;
CondTerm ::= CondFact:cond CondFactList
			{:
				RESULT=0;
			:}
			;				
CondFactList ::= CondFactList:li AND CondFact
				{:
					RESULT=li;
				:}
				|
				/*epsilon*/
				;
CondFact ::= Expr:e1 Relop:op Expr:e2
			{:
			 	if(e1.getKind()!=e2.getKind()) {
		 			parser.report_error("Nekompatibilni tipovi na liniji " + e1left,null);
		 		}
		 		RESULT=op;
		 	:}
			|
			Expr;
				
Expr ::=Expr:e Addop:op Term:t
		{:
			if(e.getKind()!=t.getKind()){
				parser.report_error("Greska na liniji: "+tleft+" nekompatibilni tipovi u izrazu.",null);
				RESULT =MyTab.noType;
			}
			if(e.getKind()!=MyStruct.Int){
				parser.report_error("Greska na liniji: "+eleft+". Izraz pre operacije mora biti tipa int.",null);
				RESULT=MyTab.noType;
			}
			if(t.getKind()!=MyStruct.Int){
				parser.report_error("Greska na liniji: "+tleft+". Izraz mora biti tipa int.",null);
				RESULT=MyTab.noType;
			}
			Code.put(op.intValue());
			RESULT=e;
		:}
		|
		MINUS Term:t
		{:
		if(t.getKind()!=Struct.Int){
			parser.report_error("Greska na liniji:"+tleft+". Promenljiva u izrazu mora biti tipa Int.",null);
			RESULT=MyTab.noType;
		}
		else{
			Code.put(Code.neg);
			RESULT=t;
		}
		:}
		|
		Term:t
		{:
		RESULT=t;
		:}
		;

Term ::= Factor:f1
		{:
		 RESULT=f1; 
		 :}
		 |
		 Term:t1 Mulop:op Factor:t2
		 {:
		 if(t1.getKind()!=t2.getKind()) {
			parser.report_error("Greska na liniji: "+t1left+" nekompatibilni tipovi u izrazu.",null);
			RESULT=MyTab.noType;
		 }
		 if(t1.getKind()!=Struct.Int||t2.getKind()!=Struct.Int){
		 	parser.report_error("Greska na liniji: "+t1left+". Tip promenljive u izrazu mora biti Int.",null);
		 	RESULT=MyTab.noType;
		 }
		 Code.put(op.intValue());
		 RESULT = t1;
		 :}
		; 
Designator ::= Designator:d DOT IDENT:i
			   {:	
			  		if(d.getType().getKind() != Struct.Class) {
			   			parser.report_error("Semanticka greska na liniji " + dleft + ": ime " + d.getName() + " nije klasa!", null);
			   			RESULT = MyTab.noObj;
			   		}
			   		else {
			   			Obj ident = d.getType().getMembersTable().searchKey(i);
			   			if(ident == null) {
			   				parser.report_error("Semanticka greska na liniji " + ileft + ": ime " + i + " ne pripada klasi " + d.getName() + " !", null);
			   				RESULT = MyTab.noObj;
			   			}
			   			else {
			   				if(ident.getKind() == Obj.Fld) {
			   					parser.report_info("Koriscenje polja " + i + " na liniji " + ileft, null);
			   				}
			   				else if(ident.getKind() == Obj.Meth) { 
			   					parser.report_info(ident.getLevel()+"Koriscenje metode " + i + " na liniji " + ileft, null);
			   					
			   				}
			   				RESULT = ident;
			   			}
			   		}
			   :}
					|
	   		   IDENT:name 
	   		   {:   
	   		   		Obj simbol = MyTab.find(name);
			   		
			   		if(simbol == MyTab.noObj) 
			   			parser.report_error("Semanticka greska na liniji: " + nameleft + ", simbol " + name + " ne postoji u tabeli simbola!", null);
			   			
			   		else if(simbol.getKind() == Obj.Con) {
			   			parser.report_info("Koriscenje konstante " + name + " na liniji: " + nameleft, null);
			   		}
			   		else if(simbol.getKind() == Obj.Var||(simbol.getKind() == Obj.Type && simbol.getType().getKind() == Struct.Class)) {
			   			if(MyTab.currentScope() == functionScope) {
			   					if( functionScope.findSymbol(name) != null ) {
			   						parser.report_info("Koriscenje lokalne promenljive " + name + " na liniji " + nameleft, null);
			   					}
			   					else {
			   						parser.report_info("Koriscenje globalne promenljive " + name + " na liniji " + nameleft, null);
			   					}
			   				}
			   		}
			   		else if(simbol.getKind() == Obj.Meth) {
			   			if(MyTab.currentScope() == functionScope) {
			   				parser.report_info("Koriscenje globalne funkcije " + name + " na liniji " + nameleft, null);
						   	/*if(func.getName().equalsIgnoreCase("chr")){
								if(a.equals(Struct.Int)){
									parser.report_error("Greska na liniji: "+funcleft+". Funkcija chr mora da ima Int kao parametar.",null);
									RESULT=MyTab.noType;
								}
							}
							if(func.getName().equalsIgnoreCase("ord")){
								if(a.equals(Struct.Char)){
									parser.report_error("Greska na liniji: "+funcleft+". Funkcija ord mora da ima Char kao parametar.",null);
									RESULT=MyTab.noType;
								}
							}
							if(func.getName().equalsIgnoreCase("len")){
								if(a.equals(Struct.Array)){
									parser.report_error("Greska na liniji: "+funcleft+". Funkcija len mora da ima niz kao parametar.",null);
									RESULT=MyTab.noType;
								}
							
			   				}*/
			   				
			   			}
			   		}
			   		RESULT = simbol;
	   		   :}
	   		   |
			   Designator:o 
			   LMEDBRACE
			   {:
			   	   	Obj ime=MyTab.find(o.getName());
			   	   	if(ime==MyTab.noObj)
			   	   	{
			   	   		parser.report_error("Greska na liniji "  + oleft + ":niz nije deklarisan.",null);
			   	   		RESULT=MyTab.noObj;
			   	   	}
			   	    if (o.getType().getKind()==MyStruct.Array) { 
				   		RESULT = new Obj(Obj.Elem, "", o.getType().getElemType());
				   		Code.load(o);
				   		if(MyTab.currentScope() == functionScope) {
			   					if( functionScope.findSymbol(o.getName()) != null ) {
			   						parser.report_info("Koriscenje lokalnog niza " + o.getName() + " na liniji " + oleft, null);
			   					}
			   					else {
			   						parser.report_info("Koriscenje globalnog niza " + o.getName() + " na liniji " + oleft, null);
			   					}
			   				}
			   		} else {
			   			parser.report_error("Greska na liniji "  + oleft + ":tip nije niz",null);
			   			RESULT=MyTab.noObj;
			   		}
			   :} 
			   Expr:e
			   {:
			   	if(e.getKind()!=MyStruct.Int) {
				  		parser.report_error("Semanticka greska na liniji " + eleft + " izraz u uglastim zagradama mora biti tipa int!", null);
				  		RESULT=MyTab.noObj;
				  	}
			   :}
			   RMEDBRACE
			   {:
			   	RESULT = new Obj(Obj.Elem, "elem", o.getType().getElemType());
			   :}
	   		   ;
Factor ::=NUMBER:n 
		 {:  
		 	 Obj c=new Obj(Obj.Con,"",MyTab.intType);
		 	 c.setAdr(n.intValue());
		 	 Code.load(c);
			 RESULT=new Struct(Struct.Int);
		 :}
		 |
		 CHAR:ch
		 {: 
		 	Obj c = new Obj(Obj.Con, "", MyTab.charType);
		   	c.setAdr(ch);
		   	Code.load(c);
		 	RESULT=new Struct(Struct.Char);
		 :}
		 |
		 BOOL:b
		 {:	
		 	Obj c = new Obj(Obj.Con, "", MyTab.boolType);
		   	if(b.equals("true"))
		   		c.setAdr(1);
		   	else 
		   		c.setAdr(0);
		   	Code.load(c);
		 	RESULT=new Struct(Struct.Bool);
		 :}
		 |
		 Designator:func {:
		 	callingStack.push(func);
			actParsStack.push(0);
		 :}
		 LPAREN ActualPars:a RPAREN
		{:
			
			if(Obj.Meth == func.getKind()) {
				parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji: "+funcleft,null);
				int formalPars = func.getLevel();
				if(formalPars > actParsStack.peek()) {
					parser.report_error("Semanticka greska na liniji " + funcleft + ": broj stvarnih i formalnih parametara mora biti isti!", null);
				}
			else {
				int destAdr = func.getAdr() - Code.pc;	//func.getAdr() DAJE ADRESU PRVE INSTRUKCIJE U FJI
				Code.put(Code.call);
				Code.put2(destAdr);	
				}
			}
			else {
				parser.report_error("Greska na liniji: "+funcleft+" ime: "+func.getName()+" nije funkcija.",null);
				RESULT=MyTab.noType;
			}
			actParsStack.pop();
			callingStack.pop();
			RESULT = func.getType();
		:}
		 |
		 NEW Type:t LMEDBRACE Expr:e RMEDBRACE
		 {:
		 	Struct arrayType = new Struct(Struct.Array);
			arrayType.setElementType(t);
			Obj obj=new Obj(Obj.Var, "t", arrayType);
		 	RESULT =obj.getType();
		 	if(e.getKind()!=Struct.Int){
		 	parser.report_error("Greska na liniji: "+eleft+". Tip promenljive u nizu mora biti Int.",null);
		 	RESULT=MyTab.noType;
		 	}
		 	else{
		 			Code.put(Code.newarray);	//POD PRETPOSTAVKOM DA SE U OKVIRU OBRADE NETERMINALA EXPR NA STEK STAVIO POTREBAN OBJEKAT KOJI PREDSTAVLJA VELICINU NIZA
				   	
				   	if(t.getKind() == Struct.Char)
				   		Code.put(0);
				   	else
				   		Code.put(1);
		 	}
		 :}
		 |
		  NEW Type:t
		  {:
		  	Obj obj=new Obj(Obj.Var, "t", t);
		  	RESULT = obj.getType();
		  	if(t.getKind() != Struct.Class) {
			   		parser.report_error("Semanticka greska na liniji " + tleft + ": Tip mora biti klasa!", null);
			   		RESULT = MyTab.noType;
			}
		  :}
		 |
		 LPAREN Expr:t RPAREN
		 {:
		 	RESULT=t;
		 :}
		 |
		 Designator:d
		 {:
		 	Code.load(d);
		 	RESULT=d.getType();
		 :}
		 ;

ActualPars ::= ActPars | /*epsilon*/;
ActPars ::= ActPars COMMA Expr:e
		    {: 
		    	int ap = actParsStack.pop();
				ap++;
				actParsStack.push(ap);
				if(!callingStack.isEmpty() && callingStack.peek().getKind() == Obj.Meth) {
					if(actParsStack.peek() > callingStack.peek().getLevel()) {
						parser.report_error("Semanticka greska na liniji " + eleft + ": broj formalnih i stvarnih parametara funkcije mora biti isti!", null);
					}
					
					else  {
						Collection<Obj> locals = callingStack.peek().getLocalSymbols();
						Iterator it = locals.iterator();
						Obj fp = null;
						
						for(int i=0; i<actParsStack.peek(); i++) {
							if(it.hasNext()) {
								fp = (Obj)it.next();
									if(it.hasNext()) {
										fp = (Obj)it.next();
									}
									else {
										fp = null;
										break;
									}
							}
						}
					
						if(fp != null && e.getKind()!=fp.getKind()) {
							parser.report_error("Semanticka greska na liniji " + eleft + ": formalan i stvaran parametar moraju biti kompatibilnog tipa!", null);
						}	
					}	
				}		
		    :}
			 |
		    Expr:e 
		    {: 
		    	int ap = actParsStack.pop();
				ap++;
				actParsStack.push(ap);
				if(!callingStack.isEmpty() && callingStack.peek().getKind() == Obj.Meth) {
					if(actParsStack.peek() > callingStack.peek().getLevel()) {
						parser.report_error("Semanticka greska na liniji " + eleft + ": broj formalnih i stvarnih parametara funkcije mora biti isti!", null);
					}
					
					else  {
						Collection<Obj> locals = callingStack.peek().getLocalSymbols();
						Iterator it = locals.iterator();
						Obj fp = null;
						
						for(int i=0; i<actParsStack.peek(); i++) {
							if(it.hasNext()) {
								fp = (Obj)it.next();
									if(it.hasNext()) {
										fp = (Obj)it.next();
									}
									else {
										fp = null;
										break;
									}
							}
						}
					
						if(fp != null && e.getKind()!=fp.getKind()) {
							parser.report_error("Semanticka greska na liniji " + eleft + ": formalan i stvaran parametar moraju biti kompatibilnog tipa!", null);
						}	
					}	
				}		
		    :};
Assignop ::= EQUAL:eq {: RESULT=(int)Code.eq; :} 
			| 
			AddopRight:ar {:RESULT=(int)ar; :} 
			| 
			MulopRight:mr {: RESULT=(int)mr; :}; 
Relop ::= EQEQ
		{:RESULT=Code.eq; :} 
		| 
		NOTEQ
		{:RESULT=Code.ne; :} 
		| 
		GREATER
		{:RESULT=Code.gt; :} 
		| 
		GREATEQ 
		{:RESULT=Code.ge; :}
		|
		LOWER 
		{:RESULT=Code.lt; :}
		| 
		LOWEQ
		{:RESULT=Code.le; :};
Addop ::= AddopLeft:al {: RESULT=(Integer)al; :}
		 | 
		 AddopRight:ar {: RESULT=(Integer)ar; :};
AddopLeft ::= PLUS 
			{:RESULT=Code.add; :}
			| 
			MINUS
			{:RESULT=Code.sub; :} ;
AddopRight ::= PLUSEQ
			{:RESULT=Code.add; :} 
			 | 
			 MINUSEQ
			 {:RESULT=Code.sub; :};
Mulop ::= 
		MulopLeft:ml {: RESULT=(Integer)ml; :}
		| 
		MulopRight:mr {: RESULT=(Integer)mr; :}
		;
MulopLeft ::= MULI
			{:RESULT=Code.mul; :} 
			|
			DIVI
			{:RESULT=Code.div; :} 
			| 
			MODI
			{:RESULT=Code.rem; :};
MulopRight ::= MULEQ
		      {:RESULT=Code.mul; :} 
			  | 
			  DIVEQ
			  {:RESULT=Code.div; :}  
			  |
			  MODEQ
			  {:RESULT=Code.rem; :} ;