
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.util.MyTab;
import rs.ac.bg.etf.pp1.util.MyStruct;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.structure.SymbolDataStructure;
import java.util.Stack;
import java.util.Collection;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
parser code {:
	int printCallCount;
	boolean errorDetected=false;
	Logger log=Logger.getLogger(getClass());
	public void report_fatal_error(String message,Object info)throws java.lang.Exception{
		done_parsing();
		report_error(message,info);
	}
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska",cur_token);
	}
	public void unrecovered_syntax_error(Symbol cur_token)throws java.lang.Exception{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti",cur_token);
	}
	public void report_error(String message,Object info){
		errorDetected=true;
		StringBuilder msg=new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
	public void report_info(String message,Object info){
		StringBuilder msg=new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.info(msg.toString());
	}
:}

action code {:
	Obj currentMethod = null;
	Obj _this;
	Obj currentClass;
	
	Struct currentType, currentMethType;
	Struct varType = null;
	Struct newClass=null;
	
	boolean main=false;
	boolean returnFound=false;
	boolean in_class = false; 
	boolean in_method = false;
	boolean in_for=false;
	boolean ok=true;

	boolean vtSet = false;
	Map<String, Obj> redefiningMap = new HashMap<String, Obj>(); 
	SymbolDataStructure extendsSymbols = null;
	
	Scope globalScope = null;
	Scope classScope=null;
	//counter-i
	int array_count = 0;	
	int var_count = 0;
	int con_count = 0;
	int mainDeclarations = 0;			
:}

init with {:
	MyTab.init(); //Universe obseg
:}


scan with{:
	Symbol s=this.getScanner().next_token();
	if(s!=null && s.value!=null)
		log.info(s.toString()+" "+s.value.toString());
	return s;
:}




terminal PROG,VOID,LBRACE,RBRACE,SEMI, LPAREN, RPAREN, COMMA,PRINT,RETURN,PLUS,EQUAL, LMEDBRACE,RMEDBRACE,DOT;
terminal GREATER,LOWER,BREAK,CLASS,ELSE,CONST,IF,NEW,READ,FOR,EXTENDS,CONTINUE,STATIC;
terminal MINUS,MULI,DIVI,MODI,EQEQ,NOTEQ,GREATEQ,LOWEQ,AND,OR,PLUSEQ,MINUSEQ,MULEQ,DIVEQ,MODEQ,PLUSPLUS,MINUSMINUS;

terminal String STRING;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;

non terminal Program,MethodDecl,VarDeclList,MethodDeclList,VarDecl,StatementList, FormParamList ;
non terminal Statement,ActualPars,ClassName,Extends,OptionalMethods;
non terminal ConstDecl,ConstList,IdentList,Var,VarList;
non terminal ClassDecl,DesignatorStatement,Condition,DesignatorStatementList;
non terminal ConditionList,NumConstList,CondTermList,ClassVarDeclList;
non terminal CondFact,If,ClassVarDecl;
non terminal Assignop,AddopLeft,AddopRight,MulopRight,MulopLeft,CondTerm;
non terminal CondFactList,Matched,Unmatched,SomeDeclList,VarArgs;

non terminal Obj ProgName,Designator,FieldDeclList,Field;
non terminal Struct Type,Term,Expr,Factor;
non terminal Integer Relop,Addop,Mulop,FormPars;
non terminal Stack<MyStruct> ActPars;

Program ::= PROG ProgName:p SomeDeclList LBRACE MethodDeclList RBRACE
			{:
				MyTab.openScope();
				MyTab.chainLocalSymbols(p);
				MyTab.closeScope();
				
				for(Obj s : p.getLocalSymbols())
					if(s.getKind() == Obj.Var)
						if(s.getType().getKind() == Struct.Array)
							array_count++;
						else
							var_count++;
					else if(s.getKind() == Obj.Con)
						con_count++;
									
				parser.report_info("Broj globalnih prostih promenjivih:" + var_count,null);
				parser.report_info("Broj globalnih nizova:" + array_count,null);
				parser.report_info("Broj globalnih konstanti:" + con_count,null);
				parser.report_info("Broj deklaracija promenljivih u main-u:" + mainDeclarations,null);
			:} ;
ProgName ::= IDENT:pName
			{:
			RESULT= MyTab.insert(Obj.Prog,pName,MyTab.noType);
			globalScope=MyTab.currentScope();
			
			 :};
   
SomeDeclList ::= SomeDeclList ConstDecl
				|
				SomeDeclList VarDecl
				|
				SomeDeclList ClassDecl
				|
				/*epsilon*/
				;
ConstDecl ::= CONST Type IDENT:name EQUAL ConstList:o IdentList SEMI
			 {:
				  	if(MyTab.currentScope.findSymbol(name) != null)
				  		parser.report_error("Greska na liniji: "+nameleft+". Vec postoji identifikator sa imenom: " + name,null);
				  	else {
				  		Obj temp = MyTab.insert(Obj.Con, name, currentType);
				  		if(!o.equals(currentType))
				  			parser.report_error("Greska na liniji: " + nameleft+" . Tip koji se dodeljuje ne odgovara tipu kome se dodeljuje. ",null);
				  		parser.report_info("Deklarisana globalna konstanta " + name + " na liniji " + nameleft, null);
				  	}
			  :}
			  |
			  CONST error SEMI:s 
			  {: 
			  	parser.report_info("Uspesan oporavak od greske na liniji " + sleft + " pri definisanju konstante.",null); 
		  	  :};
IdentList ::=IdentList COMMA IDENT:name EQUAL ConstList:o 
			{:
				if(MyTab.currentScope.findSymbol(name) != null)
				  		parser.report_error("Greska na liniji: "+nameleft+". Vec postoji identifikator sa imenom: " + name,null);
				  	else {
				  		Obj temp = MyTab.insert(Obj.Con, name, currentType);
				  		if(!o.equals(currentType))
				  			parser.report_error("Greska na liniji: " + nameleft+" . Tip koji se dodeljuje ne odgovara tipu kome se dodeljuje. ",null);
				  		parser.report_info("Deklarisana globalna konstanta " +name + " na liniji " + nameleft, null);
				  	}
			:}
			|
			/*epsilon*/
			;
ConstList ::= NUMBER:num
			{:
				RESULT = MyTab.intType;  
			:}
			|CHAR:chr
			{:
				RESULT = MyTab.charType; 
			:}
			|BOOL:bool
			{:
				RESULT = MyTab.boolType; 
			:}
			;
VarDecl ::= Type VarList SEMI
			{:
				currentType=null;
			:}
				|
		    Type error SEMI:s 
		   	{: 
		   		currentType=null;
		  		parser.report_info("Uspesan oporavak od greske pri definisanju globalne promenljive na liniji " + sleft,null); 
	  	   	:};
VarList ::= Var COMMA VarList 
			| 
			Var
			| 
			error COMMA:c VarList
			{:
			parser.report_info("Uspesan oporavak od greske pri definisanju globalne promenljive na liniji " + cleft,null); 
			:}
			;
Var ::= IDENT:name
		{:	
			Obj var = MyTab.find(name);
			if(var != MyTab.noObj) {
				parser.report_error("Semanticka greska na liniji " + nameleft + " : Ime promenljive vec postoji!", null);
			}
			else if(currentType != null) {
				MyTab.insert(Obj.Var, name, currentType);
				parser.report_info("Deklarisana promenljiva " + name + " na liniji " + nameleft, null);
			}
		:}
 			|
 		IDENT:name LMEDBRACE RMEDBRACE
 		{: 
			Obj var = MyTab.find(name);
			if(var != MyTab.noObj) {
				parser.report_error("Semanticka greska na liniji " + nameleft + " : Ime promenljive vec postoji!", null);
			}
			else if(currentType != null) {
				Struct arrayType = new Struct(Struct.Array);
				arrayType.setElementType(currentType);
				MyTab.insert(Obj.Var, name, arrayType);
				parser.report_info("Deklarisan niz " + name + " na liniji " + nameleft, null);
			}
		:};
ClassDecl ::= CLASS ClassName:c Extends 	
			  {:
			  	//PRVO UBACUJEMO POLJA POTKLASE
			  	//DRUGO UBACUJEMO POLJA NATKLASE
			  	//TRECE UBACUJEMO METODE POTKLASE
			  	//CETVRTO UBACUJEMO METODE NATKLASE
			  				  	
			  	if(extendsSymbols!=null) {
				  	for(Obj s: extendsSymbols.symbols()) {
				  			if(s.getKind() == Obj.Fld) {	//POLJE
				  				if(MyTab.currentScope().findSymbol(s.getName()) == null) {
				  					Obj obj = MyTab.insert(s.getKind(), s.getName(), s.getType());
				  				}
				  			}
				  			else if(s.getKind() == Obj.Meth) {
				  				if(MyTab.currentScope().findSymbol(s.getName()) == null) {
				
									Obj currentMeth = MyTab.insert(s.getKind(), s.getName(), s.getType());
										
									currentMeth.setLevel(s.getLevel());
									currentMeth.setAdr(s.getAdr());
										
									MyTab.openScope();
												
									Collection<Obj> locals = s.getLocalSymbols();
									Iterator it = locals.iterator();
										
									for(int i=0; i<s.getLevel(); i++) {
										if(it.hasNext()) {
											MyTab.currentScope().addToLocals((Obj)it.next());
										}
									}
									MyTab.chainLocalSymbols(currentMeth);
									MyTab.closeScope();
									
									//UBACIVANJE U VIRTUELNU TABELU
									String name = currentMeth.getName().toString();
									for(int i=0; i<name.length(); i++) {	
										Obj obj = new Obj(Obj.Var, "#" + globalScope.getnVars() + name.charAt(i), MyTab.charType);
										
										globalScope.addToLocals(obj);
										
										if(!vtSet) {
											Obj vtPtr = MyTab.currentScope().findSymbol("vtPtr");
											
											vtPtr.setFpPos(obj.getAdr());
										}
										obj.setLevel(0);
									}
									
									//DA SE ZNA DA JE KRAJ IMENA
									Obj obj = new Obj(Obj.Var, "#" + globalScope.getnVars() + "-1", MyTab.intType);
									globalScope.addToLocals(obj);
									obj.setLevel(0);
									obj = new Obj(Obj.Var, "#adr_" + name.toString() + globalScope.getnVars() + "-" + currentMeth.getAdr(), MyTab.intType);
									globalScope.addToLocals(obj);
									//OVDE MI TREBA OBJ.GETADR ZBOG REDEFFINISANJA
									redefiningMap.put(currentMeth.getName(), obj);
									obj.setLevel(0);
								}
				  			}
				  	}
					
					MyTab.chainLocalSymbols(newClass);
				}
				
			  :}
			  LBRACE ClassVarDeclList OptionalMethods RBRACE 
			  {: 
					
				MyTab.chainLocalSymbols(newClass);
				
			  	if(true) {		//if(ok)							  
			  		Obj obj = new Obj(Obj.Var, "#vt_finish" + globalScope.getnVars(), MyTab.intType);
			  		globalScope.addToLocals(obj);
			  		obj.setLevel(0);
			  		MyTab.closeScope();
			  		vtSet = false;
			  		parser.report_info("Definisana klasa " + c + " na liniji " + cleft, null);
			  	}
			  	
			  	classScope = null;
			  	newClass = null;
			  	extendsSymbols = null;
			  	
			  	redefiningMap.clear();
			  :} 
			  ;
OptionalMethods::=LBRACE MethodDeclList RBRACE
				|
				/*epsilon*/;			  
ClassName ::= IDENT:className 
			  {:
			  	Obj classNode = MyTab.find(className);
			  	if(classNode != MyTab.noObj) {
			  		parser.report_error("Semanticka greska na liniji " + classNameleft + " : Ime klase se vec koristi! ", null);
			  		RESULT = MyTab.noObj;
			  		ok = false;
			  	}
			  	else {				
			  		newClass = new Struct(Struct.Class);
				  	
				  	Obj obj = MyTab.insert(Obj.Type, className, newClass);				  	
				  	
				  	RESULT=className;
				  	MyTab.openScope();
				  	
				  	classScope = MyTab.currentScope();
				  	
				  	Obj vtPtr = MyTab.insert(Obj.Fld, "vtPtr", MyTab.intType);
				  					  	
				  	MyTab.chainLocalSymbols(newClass);
				  	
				  	parser.report_info("Obradjuje se klasa " + className + " na liniji " + classNameleft, null);
				  	ok = true;
					
				}
			  :};

Extends ::= EXTENDS Type:t 
			{:
				if(t.getKind() != Struct.Class) {
					parser.report_error("Semanticka greska na liniji " + tleft + ": Tip za extends mora biti klasa! ", null);
				}
				else {
					
					newClass.setElementType(t);	//POSTAVIMO KO MU JE NATKLASA!!!
					
					extendsSymbols = t.getMembersTable();
					
					
					MyTab.chainLocalSymbols(newClass);
					RESULT=t;
				}
			:}   
			| 
			error 
			|
			EXTENDS error
			| 
			/*epsilon*/;	/*mozda moze i EXTENDS error*/

ClassVarDeclList ::= ClassVarDeclList ClassVarDecl | /*epsilon*/;

ClassVarDecl ::= Type FieldDeclList SEMI
				 |
				 Type error:e SEMI
				 {: 
				 parser.report_error("Uspesan oporavak od greske na liniji: "+eleft+".",null); :} 
				 |
				 error
				 |
				 Type error
				 ;

FieldDeclList ::= FieldDeclList COMMA Field | Field ;

Field ::=IDENT:vName 
		  {: 

			Obj var = MyTab.currentScope().findSymbol(vName);
			
			if(var != null) {
			
				if(newClass.getElemType() !=null && newClass.getElemType().getMembersTable().searchKey(vName) == null)
					
					parser.report_error("Semanticka greska na liniji " + vNameleft + " : Ime promenljive vec postoji!", null);
				
				else {
					MyTab.currentScope().getLocals().deleteKey(vName);
					
					MyTab.insert(Obj.Fld, vName, currentType);
				
					MyTab.chainLocalSymbols(newClass);
					
					parser.report_info("Deklarisano polje " + vName + " tipa " + currentType + " na liniji " + vNameleft, null);
				}
			}
			else if(currentType != null) {
				MyTab.insert(Obj.Fld, vName, currentType);
				
				MyTab.chainLocalSymbols(newClass);
				
				parser.report_info("Deklarisano polje " + vName + " tipa " + currentType + " na liniji " + vNameleft, null);
			}
		  :}
		  |
		  IDENT:vName LMEDBRACE RMEDBRACE 
		  {: 
			//proveri da li ima kolizije
			Obj var = MyTab.currentScope().findSymbol(vName);
			if(var != null) {
				if(newClass.getElemType() !=null && newClass.getElemType().getMembersTable().searchKey(vName) == null)
					
					parser.report_error("Semanticka greska na liniji " + vNameleft + " : Ime promenljive vec postoji!", null);
				
				else {
					MyTab.currentScope().getLocals().deleteKey(vName);
					
					Struct arrayType = new Struct(Struct.Array);
					arrayType.setElementType(currentType);
					MyTab.insert(Obj.Fld, vName, arrayType);
					
					MyTab.chainLocalSymbols(newClass);
					
					parser.report_info("Deklarisan niz kao polje " + vName + " na liniji " + vNameleft, null);
				}
			}
			else if(currentType != null) {
				Struct arrayType = new Struct(Struct.Array);
				arrayType.setElementType(currentType);
				MyTab.insert(Obj.Fld, vName, arrayType);
				
				MyTab.chainLocalSymbols(newClass);
				
				parser.report_info("Deklarisan niz kao polje " + vName + " na liniji " + vNameleft, null);
			}
		  :}
		  ; 
MethodDeclList ::= MethodDeclList:m MethodDecl
				  {:
				   RESULT=m;
				  :}
				  |
				  /*epsilon*/
				  ;
MethodDecl ::=Type:retType IDENT:methName
			{:
				in_method=true;
				currentMethod=MyTab.insert(Obj.Meth,methName,retType);
				currentMethType=retType;
				MyTab.openScope();
				parser.report_info("Obradjuje se metoda: "+methName+" na liniji "+methNameleft,null);
			:} 
			LPAREN FormPars  RPAREN VarDeclList LBRACE StatementList RBRACE
			{: 
				if(in_class) 
					  		_this = MyTab.insert(Obj.Var, "this", MyTab.noType);
				if(!returnFound && retType != MyTab.noType)
					parser.report_error("Semanticka greska na liniji: "+methNameleft+". Funkcija: "+methName+" nema return iskaz.",null);
				MyTab.chainLocalSymbols(currentMethod);
				returnFound=false;
				currentMethod=null;	
				currentMethType=null;
				MyTab.closeScope();
				in_method=false;
			:}
			|
			STATIC Type:retType IDENT:methName
			{:  
				if(!in_class==true)
					parser.report_error("Greska na liniji: "+retTypeleft+". Staticka funkcija: "+methName+" mora biti unutar klase.",null);
				in_method=true;
				currentMethod=MyTab.insert(Obj.Meth,methName,retType);
				currentMethType=retType;
				MyTab.openScope();
				parser.report_info("Obradjuje se metoda: "+methName+" na liniji "+methNameleft,null);
			:} 
			LPAREN FormPars  RPAREN VarDeclList LBRACE StatementList RBRACE
			{: 
				if(!returnFound && retType != MyTab.noType)
					parser.report_error("Semanticka greska na liniji: "+methNameleft+". Funkcija: "+methName+" nema return iskaz.",null);
				MyTab.chainLocalSymbols(currentMethod);
				returnFound=false;
				currentMethod=null;	
				currentMethType=null;
				MyTab.closeScope();
				in_method=false;
			:}
			;
VarArgs ::=Type:typeName DOT DOT DOT IDENT
			|
			/*epsilon*/;				
			
VarDeclList ::= VarDeclList VarDecl
				|
				/*epsilon*/
				;
FormPars ::= Type:type IDENT:name LMEDBRACE RMEDBRACE FormParamList VarArgs
			{:
				parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
				if(MyTab.currentScope.findSymbol(name)!=null)
					{
						parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
					}
				else {
					Obj temp = MyTab.insert(Obj.Var, name, MyTab.referenceType);
					}
			
			:}
			|
			Type:type IDENT:name FormParamList VarArgs
			{:
				parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
				if(MyTab.currentScope.findSymbol(name)!=null)
					{
						parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
					}
				else {
					Obj temp = MyTab.insert(Obj.Var, name, currentType);
					}
			
			:}
			| 
			VarArgs;
			
FormParamList ::= FormParamList:f COMMA Type:type IDENT:name LMEDBRACE RMEDBRACE
				  {:
					parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
					if(MyTab.currentScope.findSymbol(name)!=null)
						{
							parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
						}
					else {
						Obj temp = MyTab.insert(Obj.Var, name, MyTab.referenceType);
						RESULT=f;
						}
			
				  :}
				  |
				  FormParamList:f COMMA Type:type IDENT:name
				  {:
					parser.report_info("Parametar funkcije: "+name+" na liniji "+nameleft,null);
					if(MyTab.currentScope.findSymbol(name)!=null)
						{
							parser.report_error("Vec postoji promenljiva sa imenom: " + name,null);
						}
					else {
						Obj temp = MyTab.insert(Obj.Var, name, currentType);
						RESULT=f;
						}
			
				  :}
				  |
				  /*epsilon*/
				  ;
Type ::= VOID
		{:
			RESULT=MyTab.noType;
		:}
		|
		IDENT:vType
		{:
			Obj typeNode = MyTab.find(vType);
			if(typeNode != MyTab.noObj) {
				if(typeNode.getKind() == Obj.Type) {
					currentType = typeNode.getType();
					
					//OVDE PROVERI DA LI JE U PITANJU KLASA DA BI PRIKAZALA KORISCENJE
					if(currentType.getKind() == Struct.Class)
						parser.report_info("Koriscenje klase " + vType + " kao tipa na liniji " + vTypeleft, null);
					
					RESULT = currentType;
				}
				else {
					parser.report_error("Ime " + vType + " nije tip!" , null);
					RESULT = MyTab.noType;
				}
			}
			else {
				parser.report_error("Semanticka greska na liniji " + vTypeleft + ":" + " Nije pronadjen tip " + vType + "!" , null);
				RESULT = MyTab.noType;
			}
		:}
		;
		
Statement ::= Matched | Unmatched;
If::=IF LPAREN Condition:cond
			{:
				if(!cond.equals(MyTab.boolType)){
					parser.report_error("Greska na liniji: "+condleft+". Uslov mora biti boolean tipa.",null);
				}
			:} 
			RPAREN;
Unmatched ::= If Statement
			| 
			If Matched ELSE Unmatched;
Matched ::= DesignatorStatement SEMI
			|
			Designator:func LPAREN ActualPars RPAREN SEMI
			{:
			if(Obj.Meth == func.getKind()){
				parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji: "+funcleft,null);
				RESULT=func.getType();
				}
			else {
				parser.report_error("Greska na liniji: "+funcleft+" ime: "+func.getName()+" nije funkcija.",null);
				RESULT=MyTab.noType;
				}
			:}
			|
			If Matched ELSE Matched
			|
			FOR LPAREN DesignatorStatementList SEMI ConditionList SEMI DesignatorStatementList RPAREN
			{:
				in_for=true;
			:}
			Matched
			{:
				in_for=false;
			:}
			|
			BREAK:b SEMI
			{:
				if(in_for==false)
					parser.report_error("Greska na liniji: "+bleft+". Break mora biti unutar for petlje.",null);
			:}
			|
			CONTINUE:c SEMI
			{:
				if(in_for==false)
					parser.report_error("Greska na liniji: "+cleft+". Continue mora biti unutar for petlje.",null);
			:}
			|
			RETURN Expr:t
			{:	
				returnFound=true;
				if(currentMethType==MyTab.noType){
					parser.report_error("Greska na liniji: "+tleft+". Povratni tip funkcije je VOID i ne moze imati vrednost u return iskazu.",null);
				}
				if(!currentMethType.compatibleWith(t)){
					parser.report_error("Greska na liniji: "+tleft+". Tip izraza u return naredbi se ne slaze sa tipom povratne vrednosti funkcije.",null);
				
				}
			:} 
			SEMI
			|
			RETURN:linija SEMI
			{:
				if (currentMethType != MyTab.noType)
					parser.report_error("Greska na liniji "+ linijaleft + ":metod ne sme imati return bez izraza jer nije void!",null);
			:}
			|
			READ LPAREN Designator:des RPAREN SEMI
			{:
				if (!des.getType().equals(MyTab.boolType)&&!des.getType().equals(MyTab.intType)&&!des.getType().equals(MyTab.charType))
					parser.report_error("Greska na liniji "+ desleft + ". Izraz mora biti integer, boolean ili char.",null);
			:}
			|
			PRINT LPAREN Expr:e NumConstList RPAREN SEMI
			{:
				if (!e.equals(MyTab.boolType)&&!e.equals(MyTab.intType)&&!e.equals(MyTab.charType))
					parser.report_error("Greska na liniji "+ eleft + ". Izraz mora biti integer, boolean ili char.",null);
			:}
			|
			LBRACE StatementList RBRACE
			 ;
StatementList ::= StatementList Statement
			     |
			     /*epsilon*/
			     ;
ConditionList ::=Condition| /*epsilon*/;
NumConstList ::= COMMA NUMBER|/*epsilon*/;
DesignatorStatementList ::=DesignatorStatement
							|
							/*epsilon*/
							;
DesignatorStatement ::= Designator:dest Assignop Expr:e
						{:
							Obj ex=MyTab.find(e.toString());
							if (e.getKind()!=dest.getType().getKind()) {
		 						parser.report_error( "Ovaj tip se ne moze dodeliti promenjivoj tipa: " + dest.getType().getKind() + " - Greska na liniji " + destleft,null);
		 						RESULT=MyTab.noType;
		 						}
							RESULT=dest;
						:}
						|
						Designator:dest PLUSPLUS
						{:
							if(dest!=null) {
							if(!dest.equals(MyTab.intType)) 
		 						parser.report_error("Promenljiva: "+dest+" mora biti tipa int. - Greska na liniji " + destleft,null);
							}
							else {
								parser.report_error("Ne postoji izraz koji se uvecava. - Greska na liniji " + destleft,null);
							}
							RESULT=dest;
						:}
						|
						Designator:dest MINUSMINUS
						{:
							if(dest!=null) {
							if(!dest.equals(MyTab.intType)) 
		 						parser.report_error("Promenljiva: "+dest+" mora biti tipa int. - Greska na liniji " + destleft,null);
							}
							else {
								parser.report_error("Ne postoji izraz koji se umanjuje. - Greska na liniji " + destleft,null);
							}
							RESULT=dest;
						:}
						;
Condition ::= CondTerm:cond CondTermList
			 {:
			 	RESULT=cond;
			 :}
			 ;
CondTermList ::= CondTermList OR CondTerm
				|
				/*epsilon*/
				;
CondTerm ::= CondFact:cond CondFactList
			{:
				RESULT=cond;
			:}
			;				
CondFactList ::= CondFactList AND CondFact
				|
				/*epsilon*/
				;
CondFact ::= Expr:e1 Relop Expr:e2
			{:
			 	if(!e1.compatibleWith(e2)) {
		 			parser.report_error("Nekompatibilni tipovi na liniji " + e1left,null);
		 		}
		 		RESULT=MyTab.boolType;
		 	:}
			|
			Expr;
				
Expr ::=Expr:e Addop Term:t
		{:
			if(e.getKind()!=t.getKind()){
				parser.report_error("Greska na liniji: "+tleft+" nekompatibilni tipovi u izrazu.",null);
				RESULT =MyTab.noType;
			}
			if(e.getKind()!=MyStruct.Int){
				parser.report_error("Greska na liniji: "+eleft+". Izraz pre operacije mora biti tipa int.",null);
				RESULT=MyTab.noType;
			}
			if(t.getKind()!=MyStruct.Int){
				parser.report_error("Greska na liniji: "+tleft+". Izraz mora biti tipa int.",null);
				RESULT=MyTab.noType;
			}
			RESULT=e;
		:}
		|
		MINUS Term:t
		{:
		RESULT=t;
		:}
		|
		Term:t
		{:
		RESULT=t;
		:}
		;

Term ::= Factor:f1
		{:
		 RESULT=f1; 
		 :}
		 |
		 Term:t1 Mulop Factor:t2
		 {:
		 if(t1.getKind()!=t2.getKind()) {
		 					parser.report_error("Greska na liniji: "+t1left+" nekompatibilni tipovi u izrazu.",null);
		 					RESULT=MyTab.noType;
		 				}
		 RESULT = t1;
		 :}
		; 
Designator ::= Designator:d DOT IDENT:i
			   {:	
			  		if(d.getType().getKind() != Struct.Class) {
			   			parser.report_error("Semanticka greska na liniji " + dleft + ": ime " + d.getName() + " nije klasa!", null);
			   			RESULT = MyTab.noObj;
			   		}
			   		else {
			   			Obj ident = d.getType().getMembersTable().searchKey(i);
			   			if(ident == null) {
			   				parser.report_error("Semanticka greska na liniji " + ileft + ": ime " + i + " ne pripada klasi " + d.getName() + " !", null);
			   				RESULT = MyTab.noObj;
			   			}
			   			else {
			   				if(ident.getKind() == Obj.Fld) {
			   					parser.report_info("Koriscenje polja " + i + " na liniji " + ileft, null);
			   				}
			   				else if(ident.getKind() == Obj.Meth) { 
			   					parser.report_info(ident.getLevel()+"Koriscenje metode " + i + " na liniji " + ileft, null);
			   					
			   				}
			   				RESULT = ident;
			   			}
			   		}
			   :}
					|
	   		   IDENT:name 
	   		   {:   
	   		   		String s = name;
	   		   		int try_no=0;
	   		   		do {
	   		   			RESULT = MyTab.find(s);
	   		   			s = "super." + s;
	   		   		} while(RESULT  == MyTab.noObj && try_no++<10);
	   		   		
	   		   		
	   		   		parser.report_info("Koriscenje identifikatora " +  RESULT.getKind() + " " + name + " na liniji " +  nameleft,null);
	   		   		
	   		   		if(RESULT == MyTab.noObj)
	   		   			parser.report_error("Greska na liniji "  + nameleft + ":promenjiva " + name + " nije deklarisana",null);
	   		   :}
	   		   |
			   Designator:o 
			   LMEDBRACE
			   {:
			   	   	Obj ime=MyTab.find(o.getName());
			   	   	if(ime==MyTab.noObj)
			   	   	{
			   	   		parser.report_error("Greska na liniji "  + oleft + ":niz nije deklarisan.",null);
			   	   		RESULT=MyTab.noObj;
			   	   	}
			   	    if (o.getType().getKind()==MyStruct.Array) { 
				   		RESULT = new Obj(Obj.Elem, "", o.getType());
			   		} else {
			   			parser.report_error("Greska na liniji "  + oleft + ":tip nije niz",null);
			   			RESULT=MyTab.noObj;
			   		}
			   :} 
			   Expr:e
			   {:
			   	if(e.getKind()!=MyStruct.Int) {
				  		parser.report_error("Semanticka greska na liniji " + eleft + " izraz u uglastim zagradama mora biti tipa int!", null);
				  		RESULT=MyTab.noObj;
				  	}
			   :}
			   RMEDBRACE
			   {:
			   	RESULT = new Obj(Obj.Elem, "elem", o.getType().getElemType());
			   :}
	   		   ;
Factor ::=NUMBER:n 
		 {:  
		 	 
			 parser.report_info("PREPOZNAT JE BROJ: "+n,null);
			 RESULT=new Struct(Struct.Int);
		 :}
		 |
		 CHAR:c
		 {: 
		 	RESULT=new Struct(Struct.Char);
		 :}
		 |
		 BOOL:b
		 {:	
		 	RESULT=new Struct(Struct.Bool);
		 :}
		 |
		 Designator:func LPAREN ActualPars RPAREN
		{:
			if(Obj.Meth == func.getKind()) {
				parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji: "+funcleft,null);
				RESULT=func.getType();
				}
			else
				parser.report_error("Greska na liniji: "+funcleft+" ime: "+func.getName()+" nije funkcija.",null);
				RESULT=MyTab.noType;
		:}
		 |
		 NEW Type:t LMEDBRACE Expr:e RMEDBRACE
		 {:
		 	Struct arrayType = new Struct(Struct.Array);
			arrayType.setElementType(t);
			Obj obj=new Obj(Obj.Var, "t", arrayType);
		 	RESULT =obj.getType();
		 :}
		 |
		  NEW Type:t
		  {:
		  	Obj obj=new Obj(Obj.Var, "t", t);
		  	RESULT = obj.getType();
		  :}
		 |
		 LPAREN Expr:t RPAREN
		 {:
		 	RESULT=t;
		 :}
		 |
		 Designator:d
		 {:
		 	RESULT=d.getType();
		 :}
		 ;

ActualPars ::= ActPars | /*epsilon*/;
ActPars ::= Expr:t COMMA ActPars:ap 
		    {: 
		    	RESULT = ap;  
		    :}
			 |
		    Expr:t 
		    {: 
		    	RESULT = new Stack<MyStruct>();  
		    :};
Assignop ::= EQUAL | AddopRight | MulopRight; 
Relop ::= EQEQ | NOTEQ | GREATER | GREATEQ |LOWER | LOWEQ;
Addop ::= AddopLeft | AddopRight;
AddopLeft ::= PLUS | MINUS ;
AddopRight ::= PLUSEQ | MINUSEQ;
Mulop ::= MulopLeft | MulopRight;
MulopLeft ::= MULI | DIVI | MODI;
MulopRight ::= MULEQ | DIVEQ |MODEQ;